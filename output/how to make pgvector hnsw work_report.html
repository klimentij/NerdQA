
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>how to make pgvector hnsw work with proper pre-filter  and how to select from this if I want to pre filter by 3-4 categories? example queries</title>
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; }
                h1, h2, h3 { color: #333; }
                .nav-buttons { margin-bottom: 20px; }
                .nav-buttons button { margin-right: 10px; }
                .citation-tree { margin-top: 20px; }
                .citation-tree ul { list-style-type: none; }
                .citation-tree li { margin: 10px 0; }
                .back-to-top { text-decoration: none; color: #0066cc; }
            </style>
            <script>
                const answers = ["<h3>Implementing Pre-Filtering in pgvector with HNSW</h3>\n<p><strong>Overview of Pre-Filtering</strong>:\n- To effectively implement pre-filtering in pgvector using HNSW (Hierarchical Navigable Small World) graphs, it is advisable to create a temporary table that includes documents filtered by specific categories and owner_ids before executing the HNSW search <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a>.</p>\n<p><strong>Using Multiple Filters</strong>:\n- Incorporating multiple filters in HNSW queries can lead to performance challenges. If the filtered results do not meet the LIMIT clause requirements, the search space may need to be expanded, which can affect efficiency <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a>.</p>\n<p><strong>SQL Syntax for Filtering</strong>:\n- pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in the SQL syntax. This allows for more precise control over the results returned from the database <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a>.</p>\n<h3>Example Queries</h3>\n<ul>\n<li>When constructing queries, ensure to specify the desired categories in the WHERE clause, and consider the implications of performance when applying multiple filters. This approach will help in retrieving relevant results while maintaining query efficiency.</li>\n</ul>", "<p><strong>Implementing Pre-filtering in pgvector HNSW Queries</strong><br />\nTo effectively implement pre-filtering in pgvector with HNSW, follow these guidelines:  </p>\n<ul>\n<li>\n<p><strong>Create a Temporary Table:</strong><br />\n  It is recommended to create a temporary table of documents that are filtered by specific categories and owner_ids before executing the HNSW search. This approach helps in managing the dataset more efficiently <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.  </p>\n</li>\n<li>\n<p><strong>Utilize WHERE Clauses:</strong><br />\n  pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in the SQL syntax. This allows for precise control over the results returned, enabling the selection of documents based on 3-4 categories <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S7649464527\" class=\"citation\" id=\"cite-S7649464527\">[S7649464527]</a>.  </p>\n</li>\n</ul>\n<p><strong>Performance Considerations</strong><br />\n- <strong>Potential Performance Issues:</strong><br />\n  Be aware that using multiple filters in HNSW queries can lead to performance issues. Specifically, if the LIMIT clause is not satisfied due to insufficient filtered results, it may necessitate an expansion of the search space, which can impact query performance <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a>.  </p>\n<p><strong>Example Queries</strong><br />\nWhile specific example queries were not provided in the statements, you can construct them by combining the WHERE clauses with the HNSW search command, ensuring that the temporary table is utilized for filtering before executing the search.  </p>\n<p><strong>Conclusion</strong><br />\nBy creating a temporary table and utilizing WHERE clauses for filtering, you can effectively implement pre-filtering in pgvector HNSW queries while being mindful of potential performance issues associated with multiple filters.</p>", "<p><strong>Implementing Pre-filtering in pgvector HNSW Queries</strong>  </p>\n<p>To effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, consider the following strategies:</p>\n<ul>\n<li>\n<p><strong>Create Temporary Tables</strong>: It is recommended to create a temporary table of documents that are filtered by specific categories before executing the HNSW search. This approach helps streamline the search process by narrowing down the dataset to relevant entries <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.  </p>\n</li>\n<li>\n<p><strong>Utilize WHERE Clauses</strong>: pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in the SQL syntax. This allows for precise control over the results returned, enabling the selection of documents that meet specific criteria <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S7649464527\" class=\"citation\" id=\"cite-S7649464527\">[S7649464527]</a>.  </p>\n</li>\n</ul>\n<p><strong>Considerations for Performance</strong>  </p>\n<ul>\n<li>\n<p><strong>Performance Issues with Multiple Filters</strong>: Using multiple filters in HNSW queries can lead to performance challenges. Specifically, if the filtered results are insufficient to satisfy the LIMIT clause, the search space may need to be expanded, potentially impacting query performance <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.  </p>\n</li>\n<li>\n<p><strong>Careful Filter Selection</strong>: When implementing multiple category filters, careful consideration is necessary to avoid performance degradation. It is crucial to ensure that the filters applied do not excessively limit the results, which could lead to inefficiencies in the search process <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.  </p>\n</li>\n</ul>\n<p><strong>Example Queries</strong>  </p>\n<p>While specific example queries were not provided in the statements, a general approach would involve constructing SQL queries that incorporate both the WHERE clauses for category filtering and the HNSW search parameters. For instance:</p>\n<p><code>sql\nSELECT * FROM documents \nWHERE category IN ('Category1', 'Category2', 'Category3') \nAND owner_id = 'specific_owner' \nORDER BY vector_column &lt;-&gt; 'query_vector' \nLIMIT 10;</code></p>\n<p>This query filters documents based on specified categories and an owner ID while performing the HNSW search based on a vector similarity measure.  </p>\n<p><strong>Conclusion</strong>  </p>\n<p>In summary, to make pgvector HNSW work effectively with proper pre-filtering, it is essential to create temporary tables for filtered documents and utilize WHERE clauses for precise filtering. However, attention must be paid to the potential performance issues that can arise from using multiple filters, ensuring that the search remains efficient and effective.</p>", "<h3>Implementing Pre-filtering in pgvector HNSW Queries</h3>\n<p>To effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, consider the following strategies:</p>\n<ul>\n<li>\n<p><strong>Create Temporary Tables</strong>: It is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search. This approach helps streamline the search process by narrowing down the dataset <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.</p>\n</li>\n<li>\n<p><strong>Use WHERE Clauses</strong>: pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax. This allows for precise control over the results returned, enabling the inclusion of multiple category filters <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S0145005482\" class=\"citation\" id=\"cite-S0145005482\">[S0145005482]</a>.</p>\n</li>\n</ul>\n<h3>Performance Considerations</h3>\n<p>When using multiple filters in HNSW queries, it is essential to consider the following:</p>\n<ul>\n<li>\n<p><strong>Performance Issues</strong>: Using multiple filters can lead to performance issues, particularly if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space, which can impact overall performance <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.</p>\n</li>\n<li>\n<p><strong>Careful Management of Limits</strong>: Ensure that the LIMIT clause is carefully managed to avoid performance degradation. If the filtered results are too few, it may be necessary to adjust the filtering criteria or the search parameters <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5672897844\" class=\"citation\" id=\"cite-S5672897844\">[S5672897844]</a>.</p>\n</li>\n</ul>\n<h3>Example Queries</h3>\n<p>To illustrate the implementation of pre-filtering by 3-4 categories, consider the following example query structure:</p>\n<p><code>sql\nSELECT * FROM documents \nWHERE category IN ('Category1', 'Category2', 'Category3') \nAND owner_id IN (1, 2, 3) \nORDER BY vector_column &lt;-&gt; 'your_vector' \nLIMIT 10;</code></p>\n<p>This SQL query filters documents based on specified categories and owner IDs, optimizing the search by focusing on relevant entries before applying the HNSW algorithm.</p>\n<h3>Conclusion</h3>\n<p>In summary, to make pgvector HNSW work effectively with proper pre-filtering by multiple categories:\n- Utilize temporary tables and WHERE clauses for efficient filtering.\n- Be mindful of potential performance issues related to the LIMIT clause.\n- Structure queries carefully to ensure optimal results.</p>", "<h3>Implementing Pre-Filters in pgvector HNSW Queries</h3>\n<p><strong>Overview of Pre-Filtering</strong><br />\nTo effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, it is recommended to create a temporary table of documents that are filtered by specific categories before executing the HNSW search <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>. This approach helps in narrowing down the search space and improving query performance.</p>\n<p><strong>Using Multiple Filters</strong><br />\npgvector allows for filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax. This enables precise control over the results returned <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>. However, using multiple filters can lead to performance issues, particularly if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.  </p>\n<p><strong>Best Practices for Optimization</strong><br />\n- <strong>Temporary Tables</strong>: Create a temporary table of filtered documents to optimize HNSW searches with multiple category filters <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a> <a href=\"#tree-S2025099863\" class=\"citation\" id=\"cite-S2025099863\">[S2025099863]</a>.<br />\n- <strong>WHERE Clauses</strong>: Utilize WHERE clauses effectively to filter results by the desired categories <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a>.<br />\n- <strong>Performance Monitoring</strong>: Monitor performance closely when using multiple filters to avoid issues with the LIMIT clause <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.  </p>\n<h3>Example Queries</h3>\n<p>When constructing queries, consider the following structure to filter by 3-4 categories:\n<code>sql\nSELECT * FROM documents  \nWHERE category IN ('Category1', 'Category2', 'Category3')  \nAND owner_id IN ('Owner1', 'Owner2')  \nORDER BY vector_column &lt;-&gt; 'your_vector'  \nLIMIT 10;</code>\nThis SQL structure allows for filtering by multiple categories and can be adjusted based on the specific needs of the query.</p>\n<h3>Conclusion</h3>\n<p>To make pgvector HNSW work effectively with proper pre-filters, it is essential to create temporary tables for filtered documents and utilize WHERE clauses for precise filtering. Careful consideration of performance implications when using multiple filters is crucial to ensure efficient query execution.</p>", "<h3>Implementing Pre-Filtering in pgvector HNSW Queries</h3>\n<p>To effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, consider the following strategies:</p>\n<ul>\n<li>\n<p><strong>Temporary Tables for Filtering</strong>: It is recommended to create a temporary table of documents that are filtered by specific categories before executing the HNSW search. This approach helps streamline the search process by narrowing down the dataset to relevant entries <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.</p>\n</li>\n<li>\n<p><strong>Using WHERE Clauses</strong>: pgvector supports filtering by multiple categories directly in HNSW queries through the integration of WHERE clauses in the SQL syntax. This allows for more precise control over the results returned <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>.</p>\n</li>\n</ul>\n<h3>Performance Considerations</h3>\n<p>When using multiple filters in HNSW queries, it is important to be aware of potential performance issues:</p>\n<ul>\n<li>\n<p><strong>Impact of Multiple Filters</strong>: Utilizing multiple filters can lead to performance challenges, particularly if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space, which can slow down query execution <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a>.</p>\n</li>\n<li>\n<p><strong>Monitoring Performance Metrics</strong>: It is crucial to monitor performance metrics such as query execution time and the effectiveness of the WHERE clause filters. This helps in assessing the recall and accuracy of the results returned <a href=\"#tree-S6728741292\" class=\"citation\" id=\"cite-S6728741292\">[S6728741292]</a> <a href=\"#tree-S3141870541\" class=\"citation\" id=\"cite-S3141870541\">[S3141870541]</a> <a href=\"#tree-S8771189535\" class=\"citation\" id=\"cite-S8771189535\">[S8771189535]</a>.</p>\n</li>\n</ul>\n<h3>Example Queries</h3>\n<p>To illustrate the implementation of pre-filtering by 3-4 categories, consider the following example SQL query structure:</p>\n<p><code>sql\nWITH filtered_docs AS (\n    SELECT * FROM documents WHERE category IN ('Category1', 'Category2', 'Category3')\n) \nSELECT * FROM hnsw_search(filtered_docs, query_vector) LIMIT 10;</code></p>\n<p>This query first filters documents based on specified categories and then performs the HNSW search on the filtered dataset.</p>\n<h3>Conclusion</h3>\n<p>In summary, to make pgvector HNSW work effectively with proper pre-filtering, it is essential to create temporary tables for filtered documents and utilize WHERE clauses for precise filtering. Careful consideration of performance implications and monitoring of relevant metrics will enhance the efficiency of the search process <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.</p>", "<h3>Implementing Pre-filtering in pgvector HNSW Queries</h3>\n<p>To effectively implement pre-filtering in pgvector with HNSW, follow these guidelines:</p>\n<ul>\n<li>\n<p><strong>Create Temporary Tables</strong>: It is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search. This approach helps streamline the search process and enhances performance <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.</p>\n</li>\n<li>\n<p><strong>Utilize WHERE Clauses</strong>: pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax. This allows for precise control over the results returned <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>.</p>\n</li>\n</ul>\n<h3>Considerations for Multiple Filters</h3>\n<ul>\n<li>\n<p><strong>Performance Issues</strong>: Using multiple filters can lead to performance issues, especially if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a> <a href=\"#tree-S6370758401\" class=\"citation\" id=\"cite-S6370758401\">[S6370758401]</a>.</p>\n</li>\n<li>\n<p><strong>Execution Time Monitoring</strong>: It is crucial to monitor the execution time of queries that utilize temporary tables for filtering, as well as the impact of multiple filters on query execution time <a href=\"#tree-S6728741292\" class=\"citation\" id=\"cite-S6728741292\">[S6728741292]</a> <a href=\"#tree-S3141870541\" class=\"citation\" id=\"cite-S3141870541\">[S3141870541]</a>.</p>\n</li>\n</ul>\n<h3>Example Queries</h3>\n<p>When constructing example queries, ensure to incorporate the necessary WHERE clauses to filter by the desired categories. For instance:\n- <strong>Basic Query Structure</strong>: \n  <code>sql\n  SELECT * FROM documents \n  WHERE category IN ('Category1', 'Category2', 'Category3')\n  AND owner_id = 'specific_owner_id';</code>\n  This query filters documents based on three categories and a specific owner ID before executing the HNSW search.</p>\n<h3>Conclusion</h3>\n<p>Implementing proper pre-filtering in pgvector HNSW queries involves creating temporary tables and using WHERE clauses for effective filtering. Careful consideration of performance implications and monitoring execution metrics is essential for optimizing query performance when using multiple filters.</p>", "<p><strong>Implementing Pre-Filters in pgvector HNSW Queries</strong><br />\nTo effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, consider the following strategies:</p>\n<ul>\n<li>\n<p><strong>Temporary Tables for Filtering:</strong><br />\n  It is recommended to create a temporary table containing documents filtered by specific categories before executing the HNSW search. This approach helps streamline the query process and ensures that only relevant data is processed <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.  </p>\n</li>\n<li>\n<p><strong>Using WHERE Clauses:</strong><br />\n  pgvector supports filtering by multiple categories directly within HNSW queries by integrating WHERE clauses into the SQL syntax. This allows for precise control over the results returned, enabling the inclusion of various filters <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>.  </p>\n</li>\n</ul>\n<p><strong>Performance Considerations</strong><br />\nWhen utilizing multiple filters in HNSW queries, it is crucial to be aware of potential performance issues:</p>\n<ul>\n<li>\n<p><strong>Impact of Multiple Filters:</strong><br />\n  Using multiple filters can lead to performance degradation, particularly if the LIMIT clause is not satisfied due to insufficient filtered results. This situation may necessitate an expansion of the search space, which could slow down query execution <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a> <a href=\"#tree-S3633928203\" class=\"citation\" id=\"cite-S3633928203\">[S3633928203]</a>.  </p>\n</li>\n<li>\n<p><strong>Monitoring Performance Metrics:</strong><br />\n  It is essential to monitor performance metrics such as query execution time and the effectiveness of WHERE clause filters. This monitoring helps assess recall and accuracy in the results returned, ensuring that the implemented filters are functioning as intended <a href=\"#tree-S6728741292\" class=\"citation\" id=\"cite-S6728741292\">[S6728741292]</a> <a href=\"#tree-S3141870541\" class=\"citation\" id=\"cite-S3141870541\">[S3141870541]</a> <a href=\"#tree-S8771189535\" class=\"citation\" id=\"cite-S8771189535\">[S8771189535]</a>.  </p>\n</li>\n</ul>\n<p><strong>Example Queries</strong><br />\nTo illustrate the application of these strategies, consider the following example queries:</p>\n<ol>\n<li>\n<p><strong>Basic Query with Pre-Filters:</strong><br />\n<code>sql  \n   SELECT * FROM documents  \n   WHERE category IN ('Category1', 'Category2')  \n   AND owner_id = 'OwnerID'  \n   LIMIT 100;</code><br />\n   This query filters documents by two categories and an owner ID before executing the HNSW search.</p>\n</li>\n<li>\n<p><strong>Advanced Query with Temporary Table:</strong><br />\n   ```sql<br />\n   CREATE TEMP TABLE filtered_docs AS<br />\n   SELECT * FROM documents<br />\n   WHERE category IN ('Category1', 'Category2', 'Category3');  </p>\n</li>\n</ol>\n<p>SELECT * FROM hnsw_search(filtered_docs);<br />\n   ```<br />\n   This example first creates a temporary table of filtered documents and then performs the HNSW search on that table.</p>\n<p><strong>Conclusion</strong><br />\nImplementing effective pre-filtering strategies in pgvector HNSW queries involves creating temporary tables and utilizing WHERE clauses for filtering. However, careful consideration of performance implications is necessary to ensure efficient query execution. Monitoring performance metrics is also crucial to optimize the filtering process and maintain query effectiveness.</p>", "<h3>Implementing Pre-Filters in pgvector HNSW Queries</h3>\n<p>To effectively implement pre-filtering in pgvector with HNSW (Hierarchical Navigable Small World) searches, consider the following strategies:</p>\n<ul>\n<li>\n<p><strong>Temporary Tables</strong>: It is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search. This approach helps streamline the search process and improves performance <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S7789477977\" class=\"citation\" id=\"cite-S7789477977\">[S7789477977]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a>.</p>\n</li>\n<li>\n<p><strong>WHERE Clauses</strong>: pgvector allows for filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax. This enables more precise control over the results returned <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>.</p>\n</li>\n</ul>\n<h3>Performance Considerations</h3>\n<p>When using multiple filters in HNSW queries, it is crucial to be aware of potential performance issues:</p>\n<ul>\n<li>\n<p><strong>LIMIT Clause</strong>: Using multiple filters can lead to performance issues, particularly if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a> <a href=\"#tree-S3633928203\" class=\"citation\" id=\"cite-S3633928203\">[S3633928203]</a>.</p>\n</li>\n<li>\n<p><strong>Execution Time Monitoring</strong>: Monitoring the execution time of queries that utilize temporary tables for filtering is essential for assessing performance <a href=\"#tree-S3141870541\" class=\"citation\" id=\"cite-S3141870541\">[S3141870541]</a>. Additionally, tracking the effectiveness of WHERE clause filters is important for evaluating recall and accuracy in the results returned <a href=\"#tree-S8771189535\" class=\"citation\" id=\"cite-S8771189535\">[S8771189535]</a>.</p>\n</li>\n</ul>\n<h3>Example Queries</h3>\n<p>For practical application, consider the following example queries when implementing pre-filters:</p>\n<ul>\n<li>\n<p><strong>Basic Query Structure</strong>: Use a SQL syntax that incorporates WHERE clauses to filter by desired categories, ensuring that the temporary table is populated with relevant documents prior to executing the HNSW search.</p>\n</li>\n<li>\n<p><strong>Combining Filters</strong>: When combining multiple filters, ensure that the query is structured to minimize the risk of performance degradation, particularly with the LIMIT clause <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a> <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a>.</p>\n</li>\n</ul>\n<h3>Conclusion</h3>\n<p>To optimize pgvector HNSW searches with multiple category filters, creating a temporary table for filtered documents and utilizing WHERE clauses in SQL are effective strategies. However, careful consideration of performance implications, especially regarding the LIMIT clause, is necessary to ensure efficient query execution.</p>", "<h3>Implementing Pre-Filters in pgvector HNSW Queries</h3>\n<p><strong>Overview</strong>: To effectively utilize pre-filters in pgvector with HNSW (Hierarchical Navigable Small World) searches, it is essential to create a structured approach that optimizes performance while ensuring accurate results.</p>\n<p><strong>Creating Temporary Tables</strong>:\n- It is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search. This method helps in managing the dataset and improving query performance <a href=\"#tree-S3037071834\" class=\"citation\" id=\"cite-S3037071834\">[S3037071834]</a> <a href=\"#tree-S9330070746\" class=\"citation\" id=\"cite-S9330070746\">[S9330070746]</a> <a href=\"#tree-S2112868281\" class=\"citation\" id=\"cite-S2112868281\">[S2112868281]</a>.</p>\n<p><strong>Utilizing WHERE Clauses</strong>:\n- pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax. This allows for more precise control over the results returned <a href=\"#tree-S8816129951\" class=\"citation\" id=\"cite-S8816129951\">[S8816129951]</a> <a href=\"#tree-S3394752377\" class=\"citation\" id=\"cite-S3394752377\">[S3394752377]</a> <a href=\"#tree-S4493142357\" class=\"citation\" id=\"cite-S4493142357\">[S4493142357]</a>.</p>\n<p><strong>Performance Considerations</strong>:\n- Using multiple filters can lead to performance issues, especially if the LIMIT clause is not satisfied due to insufficient filtered results. This may necessitate an expansion of the search space <a href=\"#tree-S2204014225\" class=\"citation\" id=\"cite-S2204014225\">[S2204014225]</a> <a href=\"#tree-S5468268429\" class=\"citation\" id=\"cite-S5468268429\">[S5468268429]</a> <a href=\"#tree-S3633928203\" class=\"citation\" id=\"cite-S3633928203\">[S3633928203]</a>.\n- Careful consideration of the LIMIT clause is crucial to avoid potential performance degradation when applying multiple filters <a href=\"#tree-S5672897844\" class=\"citation\" id=\"cite-S5672897844\">[S5672897844]</a> <a href=\"#tree-S6421011953\" class=\"citation\" id=\"cite-S6421011953\">[S6421011953]</a>.</p>\n<p><strong>Example Queries</strong>:\n- When constructing queries, ensure that the WHERE clauses accurately reflect the desired categories to filter. For instance, a query might look like: \n  <code>sql\n  SELECT * FROM documents WHERE category IN ('A', 'B', 'C') AND owner_id = '123';</code>\n  This query filters documents based on three categories and a specific owner ID, which can then be used to populate a temporary table for the HNSW search.</p>\n<p><strong>Monitoring Performance</strong>:\n- It is important to monitor the execution time of queries that utilize temporary tables for filtering, as well as the effectiveness of the WHERE clause filters to assess recall and accuracy in the results returned <a href=\"#tree-S6728741292\" class=\"citation\" id=\"cite-S6728741292\">[S6728741292]</a> <a href=\"#tree-S3141870541\" class=\"citation\" id=\"cite-S3141870541\">[S3141870541]</a> <a href=\"#tree-S8771189535\" class=\"citation\" id=\"cite-S8771189535\">[S8771189535]</a>.</p>\n<h3>Conclusion</h3>\n<p>Implementing pre-filters in pgvector HNSW searches requires creating temporary tables and utilizing WHERE clauses effectively. Careful attention to performance implications, especially regarding the LIMIT clause, is essential to maintain query efficiency and accuracy.</p>"];
                const answerCitations = [["S3037071834", "S2204014225", "S8816129951"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S7649464527", "S2204014225"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S7649464527", "S2204014225", "S5468268429", "S2204014225", "S5468268429"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S0145005482", "S2204014225", "S5468268429", "S2204014225", "S5672897844"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S9330070746", "S2025099863", "S8816129951", "S3394752377", "S2204014225", "S5468268429"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S6728741292", "S3141870541", "S8771189535", "S3037071834", "S2204014225", "S9330070746"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S6370758401", "S6728741292", "S3141870541"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S3633928203", "S6728741292", "S3141870541", "S8771189535"], ["S3037071834", "S7789477977", "S9330070746", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S3633928203", "S3141870541", "S8771189535", "S5468268429", "S2204014225"], ["S3037071834", "S9330070746", "S2112868281", "S8816129951", "S3394752377", "S4493142357", "S2204014225", "S5468268429", "S3633928203", "S5672897844", "S6421011953", "S6728741292", "S3141870541", "S8771189535"]];
                let currentIndex = 9;

                function showAnswer(index) {
                    if (index >= 0 && index < answers.length) {
                        document.getElementById('answer-content').innerHTML = answers[index];
                        document.getElementById('current-answer-index').textContent = `Answer ${index + 1} of ${answers.length}`;
                        
                        document.getElementById('prev-btn').disabled = (index === 0);
                        document.getElementById('next-btn').disabled = (index === answers.length - 1);
                        currentIndex = index;

                        // Update citation trees
                        const citationTrees = document.querySelectorAll('.citation-tree');
                        citationTrees.forEach(tree => {
                            const treeId = tree.id.replace('tree-', '');
                            if (answerCitations[index].includes(treeId)) {
                                tree.style.display = 'block';
                            } else {
                                tree.style.display = 'none';
                            }
                        });
                    }
                }

                window.onload = function() {
                    showAnswer(currentIndex);
                };
            </script>
        </head>
        <body>
            <h1>how to make pgvector hnsw work with proper pre-filter  and how to select from this if I want to pre filter by 3-4 categories? example queries</h1>
            <h2>Generated Answers</h2>
            <div class="nav-buttons">
                <button id="prev-btn" onclick="showAnswer(currentIndex - 1)">Previous</button>
                <span id="current-answer-index">Answer 10 of 10</span>
                <button id="next-btn" onclick="showAnswer(currentIndex + 1)">Next</button>
            </div>
            <div id="answer-content"></div>
            <h2>Citation Trees</h2>
            <div class="citation-tree" id="tree-S3037071834"><h3>Citation Tree for Statement S3037071834</h3><ul><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul><a href="#cite-S3037071834" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S2204014225"><h3>Citation Tree for Statement S2204014225</h3><ul><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul><a href="#cite-S2204014225" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S8816129951"><h3>Citation Tree for Statement S8816129951</h3><ul><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul><a href="#cite-S8816129951" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S7789477977"><h3>Citation Tree for Statement S7789477977</h3><ul><li id="tree-S7789477977"><strong>S7789477977:</strong> To implement pre-filtering in pgvector HNSW queries, create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E0168739189"><strong>E0168739189:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... When I have "pre-filters", it is chosing a query planner that returns less results than I would expect (3 instead of 10) because it is applying the "pre-filters" after finding the 10 nearest neighbors. ... I'm not enough of a postgres expert to know for sure, but in my practical experience it's a bit tricky to reason about when the planner will choose to use a pgvector index, and when it won't. My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint. To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. Why not simply force the desired behavior in the query itself by using a subquery in FROM?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S7789477977" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S9330070746"><h3>Citation Tree for Statement S9330070746</h3><ul><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul><a href="#cite-S9330070746" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S7649464527"><h3>Citation Tree for Statement S7649464527</h3><ul><li id="tree-S7649464527"><strong>S7649464527:</strong> pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax, allowing for precise control over the returned results.<ul><li id="tree-E9854176046"><strong>E9854176046:</strong> To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S7649464527" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S3394752377"><h3>Citation Tree for Statement S3394752377</h3><ul><li id="tree-S3394752377"><strong>S3394752377:</strong> pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax, enabling precise control over the results returned.<ul><li id="tree-E7828403056"><strong>E7828403056:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul><a href="#cite-S3394752377" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S0760578913"><h3>Citation Tree for Statement S0760578913</h3><ul><li id="tree-S0760578913"><strong>S0760578913:</strong> To implement pre-filtering in pgvector with HNSW, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E7206015239"><strong>E7206015239:</strong> CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S0760578913" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S5468268429"><h3>Citation Tree for Statement S5468268429</h3><ul><li id="tree-S5468268429"><strong>S5468268429:</strong> Using multiple filters in HNSW queries requires careful consideration to avoid performance issues, particularly with the LIMIT clause, which may not be satisfied if the filtered results are insufficient.<ul><li id="tree-E7828403056"><strong>E7828403056:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul><a href="#cite-S5468268429" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S5672897844"><h3>Citation Tree for Statement S5672897844</h3><ul><li id="tree-S5672897844"><strong>S5672897844:</strong> Using multiple filters in HNSW queries can lead to performance issues, necessitating careful consideration of the LIMIT clause and the potential need for temporary tables to optimize query performance.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S5672897844" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S0145005482"><h3>Citation Tree for Statement S0145005482</h3><ul><li id="tree-S0145005482"><strong>S0145005482:</strong> pgvector supports filtering by multiple categories in HNSW queries, allowing for precise control over the results returned through the integration of WHERE clauses in SQL syntax.<ul><li id="tree-E5597406919"><strong>E5597406919:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. Why not simply force the desired behavior in the query itself by using a subquery in FROM? Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S0145005482" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S2025099863"><h3>Citation Tree for Statement S2025099863</h3><ul><li id="tree-S2025099863"><strong>S2025099863:</strong> To efficiently implement pre-filtering in pgvector HNSW queries, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E0766065449"><strong>E0766065449:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? CREATE INDEX ON document USING hnsw(embedding) WHERE category = ? However, you would have to do this for every single category in the database. To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. Why might it not be feasible to automatically create an index whenever a new user joins (or a new category is created in your case)? In my own case, the difficulty is that users can share documents, so I have a separate table for storing documents and a separate table for storing ownership information, i.e. (<user id>,<document id>) pairs. ... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S2025099863" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S6421011953"><h3>Citation Tree for Statement S6421011953</h3><ul><li id="tree-S6421011953"><strong>S6421011953:</strong> Using multiple filters in pgvector HNSW queries requires careful consideration to avoid performance issues, particularly with the LIMIT clause, which may not be satisfied if the filtered results are insufficient.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li><li id="tree-S5468268429"><strong>S5468268429:</strong> Using multiple filters in HNSW queries requires careful consideration to avoid performance issues, particularly with the LIMIT clause, which may not be satisfied if the filtered results are insufficient.<ul><li id="tree-E7828403056"><strong>E7828403056:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul></li></ul><a href="#cite-S6421011953" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S3853694634"><h3>Citation Tree for Statement S3853694634</h3><ul><li id="tree-S3853694634"><strong>S3853694634:</strong> To enhance pgvector HNSW query performance with multiple filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E5597406919"><strong>E5597406919:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. Why not simply force the desired behavior in the query itself by using a subquery in FROM? Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul><a href="#cite-S3853694634" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S4493142357"><h3>Citation Tree for Statement S4493142357</h3><ul><li id="tree-S4493142357"><strong>S4493142357:</strong> pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax, allowing for precise control over the results returned.<ul><li id="tree-E7792057388"><strong>E7792057388:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. Right now if you need to combine several search criteria, Postgres can propose only two approaches: Filtered index scan (you perform index search using one criteria and filter records matching another criteria). Bitmap scan (index scans construct bitmap which you can then intersect or union and use for heap scan) First approach is not working well for HNSW because it returns limited (K) number of results.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S4493142357" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S6728741292"><h3>Citation Tree for Statement S6728741292</h3><ul><li id="tree-S6728741292"><strong>S6728741292:</strong> Performance metrics for pgvector HNSW queries with pre-filters should include monitoring the impact of multiple filters on query execution time and the LIMIT clause satisfaction.<ul><li id="tree-E9257407777"><strong>E9257407777:</strong> Hello, I&#x27;m currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I&#x27;d like to share my situation and see... Hello, I'm currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I'd like to share my situation and seek advice on potential optimizations or c... PostgreSQL version: Using the Docker image with pgvector version 0.6.0 included, which is based on PostgreSQL 16. Hardware: The server has 28 cores, 56 threads, and 256GB of RAM, but we're using HDDs instead of SSDs, which might be impacting performance. Tables: We have around 10 tables, each with approximately 10 to 20 million rows. Current settings: shared_buffers is set to 80GB, and effective_cache_size is set to 120GB. Indexes: Utilizing HNSW indexes with cosine similarity. It looks like the buffer hit rate is pretty low, so a lot of reads are happening from disk. I suspect you'll see better performance with an SSD, especially since HNSW does a lot of random access. I don't think partitioning will help in this situation (unless you're filtering by the partition key). Are there any recommended configurations or optimizations specific to pgvector, especially when dealing with large tables and HNSW indexes on an HDD setup?<br><a href="https://github.com/pgvector/pgvector/issues/455" target="_blank">https://github.com/pgvector/pgvector/issues/455</a></li><li id="tree-E6523777867"><strong>E6523777867:</strong> Increase performance in pgvector using HNSW indexes To understand the performance improvements that HNSW offers, we decided to expand upon our previous benchmarks and include results for the HNSW index in addition to IVF and compare the queries per second (QPS) for both. In the first test, we used 224,482 vectors by OpenAI (1536 dimensions). You can find our previous benchmark with additional information on how vector dimensions may affect performance in pgvector: Fewer dimensions are better. This adjustment enabled us to achieve the same level of accuracy@10 of 0.99 with an ef_search = 100 instead of the previous 250, resulting in a 35% increase in QPS. In addition to the above query performance improvements, HNSW offers another advantage: you don't need to fully fill your table before building the index. With IVFFlat indexes, the clusters (lists) are constructed based on the distribution of existing data in the table. This means that IVF indexes built on an empty table would produce completely suboptimal centers. This is why pgvector recommends building IVF indexes only once sufficient data exists in the table and rebuilding them any time the distribution of data changes significantly. If you want to find out more about pgvector 0.4.0 IVFFlat performance and our load testing methodology, check out pgvector 0.4.0 performance blogpost. Here we used the Supabase project with a 2XL compute add-on (8-core CPU and 32GB RAM) and built the HNSW index with the same parameters: ... When we maintain fixed HNSW build parameters, we can adjust the select query parameter ef_search to balance query speed and accuracy. In most cases today, HNSW offers a more performant and robust index over IVFFlat. It's worth noting though that HNSW indexes will almost always be slower to build and use more memory than IVFFlat, so if your system is memory-constrained and you don't foresee the need to rebuild your index often, you may find IVFFlat to be more suitable. It's also worth noting that product quantization (compressing index entries for vectors) is expected for IVF in the next versions of pgvector which should significantly improve performance and lower resource requirements.<br><a href="https://supabase.com/blog/increase-performance-pgvector-hnsw" target="_blank">https://supabase.com/blog/increase-performance-pgvector-hnsw</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul><a href="#cite-S6728741292" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S3141870541"><h3>Citation Tree for Statement S3141870541</h3><ul><li id="tree-S3141870541"><strong>S3141870541:</strong> To enhance performance in pgvector HNSW queries with pre-filters, it is recommended to monitor the execution time of queries that utilize temporary tables for filtering.<ul><li id="tree-E9257407777"><strong>E9257407777:</strong> Hello, I&#x27;m currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I&#x27;d like to share my situation and see... Hello, I'm currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I'd like to share my situation and seek advice on potential optimizations or c... PostgreSQL version: Using the Docker image with pgvector version 0.6.0 included, which is based on PostgreSQL 16. Hardware: The server has 28 cores, 56 threads, and 256GB of RAM, but we're using HDDs instead of SSDs, which might be impacting performance. Tables: We have around 10 tables, each with approximately 10 to 20 million rows. Current settings: shared_buffers is set to 80GB, and effective_cache_size is set to 120GB. Indexes: Utilizing HNSW indexes with cosine similarity. It looks like the buffer hit rate is pretty low, so a lot of reads are happening from disk. I suspect you'll see better performance with an SSD, especially since HNSW does a lot of random access. I don't think partitioning will help in this situation (unless you're filtering by the partition key). Are there any recommended configurations or optimizations specific to pgvector, especially when dealing with large tables and HNSW indexes on an HDD setup?<br><a href="https://github.com/pgvector/pgvector/issues/455" target="_blank">https://github.com/pgvector/pgvector/issues/455</a></li><li id="tree-E6523777867"><strong>E6523777867:</strong> Increase performance in pgvector using HNSW indexes To understand the performance improvements that HNSW offers, we decided to expand upon our previous benchmarks and include results for the HNSW index in addition to IVF and compare the queries per second (QPS) for both. In the first test, we used 224,482 vectors by OpenAI (1536 dimensions). You can find our previous benchmark with additional information on how vector dimensions may affect performance in pgvector: Fewer dimensions are better. This adjustment enabled us to achieve the same level of accuracy@10 of 0.99 with an ef_search = 100 instead of the previous 250, resulting in a 35% increase in QPS. In addition to the above query performance improvements, HNSW offers another advantage: you don't need to fully fill your table before building the index. With IVFFlat indexes, the clusters (lists) are constructed based on the distribution of existing data in the table. This means that IVF indexes built on an empty table would produce completely suboptimal centers. This is why pgvector recommends building IVF indexes only once sufficient data exists in the table and rebuilding them any time the distribution of data changes significantly. If you want to find out more about pgvector 0.4.0 IVFFlat performance and our load testing methodology, check out pgvector 0.4.0 performance blogpost. Here we used the Supabase project with a 2XL compute add-on (8-core CPU and 32GB RAM) and built the HNSW index with the same parameters: ... When we maintain fixed HNSW build parameters, we can adjust the select query parameter ef_search to balance query speed and accuracy. In most cases today, HNSW offers a more performant and robust index over IVFFlat. It's worth noting though that HNSW indexes will almost always be slower to build and use more memory than IVFFlat, so if your system is memory-constrained and you don't foresee the need to rebuild your index often, you may find IVFFlat to be more suitable. It's also worth noting that product quantization (compressing index entries for vectors) is expected for IVF in the next versions of pgvector which should significantly improve performance and lower resource requirements.<br><a href="https://supabase.com/blog/increase-performance-pgvector-hnsw" target="_blank">https://supabase.com/blog/increase-performance-pgvector-hnsw</a></li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S3141870541" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S8771189535"><h3>Citation Tree for Statement S8771189535</h3><ul><li id="tree-S8771189535"><strong>S8771189535:</strong> Monitoring the effectiveness of WHERE clause filters in pgvector HNSW queries is crucial for assessing recall and accuracy in the results returned.<ul><li id="tree-E9257407777"><strong>E9257407777:</strong> Hello, I&#x27;m currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I&#x27;d like to share my situation and see... Hello, I'm currently facing performance challenges with pgvector on PostgreSQL, particularly with large tables and queries taking significant time to execute. I'd like to share my situation and seek advice on potential optimizations or c... PostgreSQL version: Using the Docker image with pgvector version 0.6.0 included, which is based on PostgreSQL 16. Hardware: The server has 28 cores, 56 threads, and 256GB of RAM, but we're using HDDs instead of SSDs, which might be impacting performance. Tables: We have around 10 tables, each with approximately 10 to 20 million rows. Current settings: shared_buffers is set to 80GB, and effective_cache_size is set to 120GB. Indexes: Utilizing HNSW indexes with cosine similarity. It looks like the buffer hit rate is pretty low, so a lot of reads are happening from disk. I suspect you'll see better performance with an SSD, especially since HNSW does a lot of random access. I don't think partitioning will help in this situation (unless you're filtering by the partition key). Are there any recommended configurations or optimizations specific to pgvector, especially when dealing with large tables and HNSW indexes on an HDD setup?<br><a href="https://github.com/pgvector/pgvector/issues/455" target="_blank">https://github.com/pgvector/pgvector/issues/455</a></li><li id="tree-E6523777867"><strong>E6523777867:</strong> Increase performance in pgvector using HNSW indexes To understand the performance improvements that HNSW offers, we decided to expand upon our previous benchmarks and include results for the HNSW index in addition to IVF and compare the queries per second (QPS) for both. In the first test, we used 224,482 vectors by OpenAI (1536 dimensions). You can find our previous benchmark with additional information on how vector dimensions may affect performance in pgvector: Fewer dimensions are better. This adjustment enabled us to achieve the same level of accuracy@10 of 0.99 with an ef_search = 100 instead of the previous 250, resulting in a 35% increase in QPS. In addition to the above query performance improvements, HNSW offers another advantage: you don't need to fully fill your table before building the index. With IVFFlat indexes, the clusters (lists) are constructed based on the distribution of existing data in the table. This means that IVF indexes built on an empty table would produce completely suboptimal centers. This is why pgvector recommends building IVF indexes only once sufficient data exists in the table and rebuilding them any time the distribution of data changes significantly. If you want to find out more about pgvector 0.4.0 IVFFlat performance and our load testing methodology, check out pgvector 0.4.0 performance blogpost. Here we used the Supabase project with a 2XL compute add-on (8-core CPU and 32GB RAM) and built the HNSW index with the same parameters: ... When we maintain fixed HNSW build parameters, we can adjust the select query parameter ef_search to balance query speed and accuracy. In most cases today, HNSW offers a more performant and robust index over IVFFlat. It's worth noting though that HNSW indexes will almost always be slower to build and use more memory than IVFFlat, so if your system is memory-constrained and you don't foresee the need to rebuild your index often, you may find IVFFlat to be more suitable. It's also worth noting that product quantization (compressing index entries for vectors) is expected for IVF in the next versions of pgvector which should significantly improve performance and lower resource requirements.<br><a href="https://supabase.com/blog/increase-performance-pgvector-hnsw" target="_blank">https://supabase.com/blog/increase-performance-pgvector-hnsw</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S8771189535" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S2112868281"><h3>Citation Tree for Statement S2112868281</h3><ul><li id="tree-S2112868281"><strong>S2112868281:</strong> To implement pre-filtering in pgvector HNSW queries, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E8976102418"><strong>E8976102418:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case) To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. In my own case, the difficulty is that users can share documents, so I have a separate table for storing documents and a separate table for storing ownership information, i.e. (<user id>,<document id>) pairs. ... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S2112868281" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S6370758401"><h3>Citation Tree for Statement S6370758401</h3><ul><li id="tree-S6370758401"><strong>S6370758401:</strong> Using multiple filters in pgvector HNSW queries can lead to performance issues, particularly with the LIMIT clause, which may not be satisfied if the filtered results are insufficient.<ul><li id="tree-E9009529773"><strong>E9009529773:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Hi, I would like to understand how the current implementation handles HNSW + filtering. ... CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li><li id="tree-S5468268429"><strong>S5468268429:</strong> Using multiple filters in HNSW queries requires careful consideration to avoid performance issues, particularly with the LIMIT clause, which may not be satisfied if the filtered results are insufficient.<ul><li id="tree-E7828403056"><strong>E7828403056:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul></li></ul><a href="#cite-S6370758401" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S3633928203"><h3>Citation Tree for Statement S3633928203</h3><ul><li id="tree-S3633928203"><strong>S3633928203:</strong> Using multiple filters in pgvector HNSW queries can negatively impact performance, particularly when the LIMIT clause is not satisfied due to insufficient filtered results.<ul><li id="tree-E7792057388"><strong>E7792057388:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. Right now if you need to combine several search criteria, Postgres can propose only two approaches: Filtered index scan (you perform index search using one criteria and filter records matching another criteria). Bitmap scan (index scans construct bitmap which you can then intersect or union and use for heap scan) First approach is not working well for HNSW because it returns limited (K) number of results.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S3633928203" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S8653498001"><h3>Citation Tree for Statement S8653498001</h3><ul><li id="tree-S8653498001"><strong>S8653498001:</strong> Creating a temporary table of documents filtered by specific categories before executing HNSW searches can optimize query performance in pgvector.<ul><li id="tree-E9330070746"><strong>E9330070746:</strong> Snippet text not found for ID: E9330070746</li><li id="tree-S9330070746"><strong>S9330070746:</strong> To optimize HNSW searches in pgvector with multiple category filters, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E3019453754"><strong>E3019453754:</strong> To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? (In this case the condition is simple enough that you might be able to use table partitioning, but that's not always the case)<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S8653498001" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S8635063806"><h3>Citation Tree for Statement S8635063806</h3><ul><li id="tree-S8635063806"><strong>S8635063806:</strong> pgvector allows for filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax, enabling precise control over the results returned.<ul><li id="tree-E3394752377"><strong>E3394752377:</strong> Snippet text not found for ID: E3394752377</li><li id="tree-S3394752377"><strong>S3394752377:</strong> pgvector supports filtering by multiple categories in HNSW queries through the integration of WHERE clauses in SQL syntax, enabling precise control over the results returned.<ul><li id="tree-E7828403056"><strong>E7828403056:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category. It comes down to implementation: the challenge with a post-filtered search is that you'll need to see enough vectors in the index that satisfy all of the filtered conditions. Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul></li></ul><a href="#cite-S8635063806" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S7648552587"><h3>Citation Tree for Statement S7648552587</h3><ul><li id="tree-S7648552587"><strong>S7648552587:</strong> Using multiple filters in pgvector HNSW queries can lead to performance issues, particularly when the LIMIT clause is not satisfied due to insufficient filtered results.<ul><li id="tree-E9854176046"><strong>E9854176046:</strong> To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. That said, picking an indexing strategy may depend on the actual contents of your data. For example, if your category filter eliminates most rows (e.g. you have a handful of vectors to compare remaining), using the index embedding may not make sense. Or based upon your use case, you may want to perform the ANN search first and then filter out the results by category.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S2204014225"><strong>S2204014225:</strong> Using multiple filters in HNSW queries can lead to performance issues, as the LIMIT clause may not be satisfied if the filtered results are insufficient, necessitating an expansion of the search space.<ul><li id="tree-E2204014225"><strong>E2204014225:</strong> Snippet text not found for ID: E2204014225</li></ul></li></ul></li></ul><a href="#cite-S7648552587" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S3879076020"><h3>Citation Tree for Statement S3879076020</h3><ul><li id="tree-S3879076020"><strong>S3879076020:</strong> To implement category pre-filters in pgvector HNSW, it is recommended to create a temporary table of documents filtered by specific categories before executing the HNSW search.<ul><li id="tree-E0766065449"><strong>E0766065449:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future? CREATE INDEX ON document USING hnsw(embedding) WHERE category = ? However, you would have to do this for every single category in the database. To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw. Why might it not be feasible to automatically create an index whenever a new user joins (or a new category is created in your case)? In my own case, the difficulty is that users can share documents, so I have a separate table for storing documents and a separate table for storing ownership information, i.e. (<user id>,<document id>) pairs. ... To look up from both indexes at the same time, pgvector would have to add support for bitmap scans in hnsw.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-S3037071834"><strong>S3037071834:</strong> To implement pre-filtering in pgvector with HNSW, create a temporary table of documents filtered by specific categories and owner_ids before executing the HNSW search.<ul><li id="tree-E3673511444"><strong>E3673511444:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] N... Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th... Another thing that I am seeing when having more filters on the query is the behavior of the LIMIT clause. This table is partitioned by category and we have an index on owner_id and another index on the embedding (HSNW). WITH pre_filtered_docs AS ( SELECT * FROM documents WHERE ((category = ('cat-a')) AND (owner_id IN (1, 2, 3))) OR ((category = ('cat-b')) AND (owner_id IN (4, 5, 6))) ) SELECT category, owner_id, text, embedding <=> '[vector to query]' as distance FROM pre_filtered_docs ORDER BY distance LIMIT 10; Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time. CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) ... To do this efficiently is not straightforward -- ideally we want to do the expensive HNSW ANN on the already pruned subset (https://qdrant.tech/articles/filtrable-hnsw/). Can pgvector do this, or is there plan to enable such optimization in the future?<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E2696640484"><strong>E2696640484:</strong> Currently (as of v0.7.3) in pgvector, you may not be able to return enough tuples at a value of hnsw.ef_search to be able to satisfy it - and possibly with your case, you may not be able to achieve that at max hnsw.ef_search. The way for pgvector to handle that would be to expand the search to additional neighborhoods until we satisfy the LIMIT, but this comes at cost of increased query time.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li><li id="tree-E5757808181"><strong>E5757808181:</strong> Hi, I would like to understand how the current implementation handles HNSW + filtering. Imagine you have a table: CREATE TABLE document ( id UUID PRIMARY KEY, text TEXT NOT NULL, embedding REAL[] NOT NULL, category TEXT NOT NULL ) And th...<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S3879076020" class="back-to-top">↑ Back to citation</a></div><div class="citation-tree" id="tree-S4326993492"><h3>Citation Tree for Statement S4326993492</h3><ul><li id="tree-S4326993492"><strong>S4326993492:</strong> pgvector supports filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling precise control over the results returned.<ul><li id="tree-E2204801135"><strong>E2204801135:</strong> Pgvector filtering: Go beyond similarity search. Master pgvector, a PostgreSQL extension, to filter your search results with ease.<br><a href="https://justaitrends.com/pgvector-filters/" target="_blank">https://justaitrends.com/pgvector-filters/</a></li><li id="tree-S8816129951"><strong>S8816129951:</strong> pgvector allows for filtering by multiple categories in HNSW queries by integrating WHERE clauses into the SQL syntax, enabling more precise control over the results returned.<ul><li id="tree-E8409944207"><strong>E8409944207:</strong> My intention was to add to the discussion that the LIMIT clause may not be working as expected when we combine conditions with the HNSW index. ... 👋 This seems like a use-case we could make use of. It looks like https://github.com/pgvector/pgvector/tree/hqann is somewhat out of date at this point, would y'all still find it useful if we ran some testing against this branch or wait until a new build exists? ... Any updates on the hqann implementation? We are using GCP CloudSQL for PostgreSQL now, and the lack of pre-filtering has become a painpoint.<br><a href="https://github.com/pgvector/pgvector/issues/259" target="_blank">https://github.com/pgvector/pgvector/issues/259</a></li></ul></li></ul></li></ul><a href="#cite-S4326993492" class="back-to-top">↑ Back to citation</a></div>
        </body>
        </html>
        